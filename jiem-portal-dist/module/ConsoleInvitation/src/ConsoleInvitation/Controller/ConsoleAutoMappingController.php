<?php

/**
 * Zend Framework (http://framework.zend.com/)
 *
 * @link      http://github.com/zendframework/LeaningProgress for the canonical source repository
 * @copyright Copyright (c) 2005-2014 Zend Technologies USA Inc. (http://www.zend.com)
 * @license   http://framework.zend.com/license/new-bsd New BSD License
 */

namespace ConsoleInvitation\Controller;

use Dantai\DantaiConstants;
use Dantai\PrivateSession;
use Dantai\Utility\DateHelper;
use Symfony\Component\Config\Definition\Exception\Exception;
use Symfony\Component\DependencyInjection\ContainerAwareTrait;
use Zend\Mvc\Controller\AbstractActionController;
use Zend\Http\Client;
use Zend\Json\Encoder;
use Zend\Mvc\MvcEvent;

class ConsoleAutoMappingController extends AbstractActionController {
    use ContainerAwareTrait;

    protected $httpClient = null;
    protected $dantaiService;
    protected $autoMappingService;

    public function __construct() {
        $this->httpClient = new Client();
    }

    public function onDispatch(MvcEvent $e)
    {
        // create service.
        if(!$this->dantaiService) {
            $this->dantaiService = $this->getServiceLocator()->get('Application\Service\DantaiServiceInterface');
        }

        return parent::onDispatch($e); // TODO: Change the autogenerated stub
    }

    // create after create session.
    public function createAutoMappingService(){
        if(!$this->autoMappingService){
            $this->autoMappingService =  $this->getServiceLocator()->get('ConsoleInvitation\Service\AutoMappingService');
        }
    }

    public function autoMappingTestResultAction() {
        $dantaiService = $this->dantaiService;
        $return = new \Zend\View\Model\ConsoleModel();
        $objQueueInfo = $dantaiService->getAutoMappingInQueue();
        echo 'REQUEST: ' . json_encode($objQueueInfo) . PHP_EOL;
        if (empty($objQueueInfo)) {
            $return->setErrorLevel(1);

            return $return;
        }

        $item = $objQueueInfo['Body'];
        $type = $item['type'];
        $orgId = $item['orgId'];
        $orgNo = $item['orgNo'];
        $paramEiken = $item['paramEiken'];
        $paramIBA = $item['paramIBA'];
        $host = $item['host'];
        $userId = $item['userId'];
        $userIdentity = array(
            'organizationNo'   => $orgNo,
            'organizationId'   => $orgId,
            'organizationName' => '',
            'userId'           => $userId,
            'host'             => $host,
        );
        PrivateSession::setData('userIdentity', $userIdentity);
        $startDate = date(DateHelper::DATETIME_FORMAT_DEFAULT);

        // process auto-mapping IBA and EIKEN
        if ($type == DantaiConstants::EXAM_TYPE_IBA) {
            try {
                echo '[' . $startDate . '] START: process auto-mapping IBA for orgNo - ' . $orgNo . ' (orgId - ' . $orgId . ')' . PHP_EOL;
                $this->createAutoMappingService();
                $this->autoMappingService->processAutoMappingIBA($orgId, $orgNo);
                echo 'SUCCESS: process auto-mapping IBA for orgNo - ' . $orgNo . ' (orgId - ' . $orgId . ')' . PHP_EOL;
                $dantaiService->deleteAutoMappingInQueue($type, $orgId, $orgNo, $paramEiken, $paramIBA, $objQueueInfo['ReceiptHandle']);
                echo 'Delete mapping IBA queue' . PHP_EOL;
            } catch (Exception $ex) {
                echo $ex->getMessage() . PHP_EOL;
                echo 'Error: process auto-mapping IBA for orgNo - ' . $orgNo . ' (orgId - ' . $orgId . ')' . PHP_EOL;
            } finally {
                PrivateSession::clear('userIdentity');
                $endDate = date(DateHelper::DATETIME_FORMAT_DEFAULT);
                echo '[' . $endDate . '] END: Auto mapping IBA' . PHP_EOL;
            }
        } elseif ($type == DantaiConstants::EXAM_TYPE_EIKEN) {
            try {
                echo '[' . $startDate . '] START: process auto-mapping EIKEN for orgNo - ' . $orgNo . ' (orgId - ' . $orgId . ')' . PHP_EOL;
                $this->createAutoMappingService();
                $this->autoMappingService->processAutoMappingEiken($item);
                echo 'SUCCESS: process auto-mapping EIKEN for orgNo - ' . $orgNo . ' (orgId - ' . $orgId . ')' . PHP_EOL;
                $dantaiService->deleteAutoMappingInQueue($type, $orgId, $orgNo, $paramEiken, $paramIBA, $objQueueInfo['ReceiptHandle']);
                echo 'Delete mapping Eiken queue' . PHP_EOL;
            } catch (\Exception $ex) {
                echo $ex->getMessage() . PHP_EOL;
                echo 'Change status auto mapping' . PHP_EOL;
                $dantaiService->ChangeStatusAutoMappingEiken($paramEiken['applyEikenOrgId'], 0);
                echo 'Error: process auto-mapping EIKEN for orgNo - ' . $orgNo . ' (orgId - ' . $orgId . ')' . PHP_EOL;
            } finally {
                PrivateSession::clear('userIdentity');
                $endDate = date(DateHelper::DATETIME_FORMAT_DEFAULT);
                echo '[' . $endDate . '] END: Auto mapping Eiken' . PHP_EOL;
            }
        }

    }

    /**
     * Prepare API parameters structure before sending
     *
     * @param array $functionParameters
     * @return multitype:string
     */
    protected function prepareParameters(array $functionParameters) {
        $json = Encoder::encode($functionParameters);
        return array(
            'data' => $json
        );
    }

}
